[
  {
    "title": "Browser History Forensics",
    "date": "2026-03-01",
    "excerpt": "Reconstructing a redirect-to-download chain with limited telemetry, using browser artifacts when SSL inspection and endpoint visibility are sparse.",
    "url": "/blogs/post.html?post=browser-history-forensics",
    "slug": "browser-history-forensics",
    "source": "/blogs/browser-history-forensics.md",
    "markdown": "## Browser History Forensics\n\nHaving repeatable browser forensics workflows lets the operator reconstruct “how did this file get here?” when the only strong signal is a detection on disk and your network/endpoint visibility is incomplete.\n\n**No real incident data is used in this example.**  \nAll domains, URLs, and filenames are fake and intentionally defanged.\n\n### Scenario (example)\n\nA detection flags `SuspiciousPDFConverter.exe` as malware delivery via PUP, and your job is to reconstruct the redirect-to-download chain and capture defensible evidence for containment and user coaching.\n\n### MITRE tactic tag (what this investigation maps to)\n\nThis workflow most often supports **Initial Access**, commonly aligning with **T1189 (Drive-by Compromise)** when a user is redirected through web infrastructure into a download.\n\n### Tools (pick what you have)\n\n- PowerShell — Rapid artifact discovery\n- (Optional) KAPE (or Velociraptor) — Reliable collection at scale\n- DB Browser for SQLite — Fast ad-hoc queries (sqlite3 is reliable)\n- (Optional) Hindsight — Chrome history parsing and timelines\n- (Optional) Plaso/log2timeline — Cross-artifact timeline building\n\n### Known Windows history artifact paths (nuances matter)\n\n**Chrome (what we’ll analyze):**\n`C:\\Users\\JaneDoe\\AppData\\Local\\Google\\Chrome\\User Data\\<Profile>\\History`\n(Profiles are commonly `Default`, `Profile 1`, `Profile 2`, plus `Guest Profile`/`System Profile` in some environments.)\n\n**Edge (not diving in, but here’s the path):**\n`C:\\Users\\JaneDoe\\AppData\\Local\\Microsoft\\Edge\\User Data\\<Profile>\\History`\n\n**Firefox (history lives in places.sqlite):**\n`C:\\Users\\JaneDoe\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\<Profile>\\places.sqlite`\n\n\n### Evidence handling note\n\nChrome’s `History` SQLite file may be locked while Chrome is running, so plan to **copy** it with an IR-safe collector (or from a shadow copy) rather than querying it in-place. Be sure to calculate SHA256 hash before and after copying it to an investigation workstation. Before proceeding, typically the suspicious file has been remediated on the host by the operator.\n\n## 0) Quick artifact triage (before you pivot)\n\nThe goal here is to confirm origin indicators (MOTW), generate a stable pivot (SHA256), and do OSINT/sandbox validation before you invest time in deep reconstruction.\n\n### PowerShell one-liners (remote-response friendly)\n\n> # Check Mark-of-the-Web (Zone Identifier) on the suspicious executable (downloads commonly carry MOTW)\n> Get-Content \"C:\\Users\\JaneDoe\\Downloads\\SuspiciousPDFConverter.exe\" -Stream Zone.Identifier -ErrorAction SilentlyContinue\n\n\n> # Compute SHA256 for OSINT pivots (static + behavioral analytics)\n> (Get-FileHash \"C:\\Users\\JaneDoe\\Downloads\\SuspiciousPDFConverter.exe\" -Algorithm SHA256).Hash\n\n### JaneDoe quick task notes:\n\n- Confirm MOTW origin zone\n- Create hash for OSINT\n\n### OSINT + analysis note\n\nUse the **SHA256** to pivot in your approved intel sources and sandboxes to collect static traits (signing, strings, imports) and behavioral indicators (network beacons, child processes, dropped files) that can validate the alert and inform containment. Before proceeding, ensure that the suspicious file has been remediated.\n\n## 1) Find the right Chrome History file (profiles + recency)\n\nThe first goal is to identify which Chrome profile was active near the time `SuspiciousPDFConverter.exe` landed by selecting the most recently written `History` databases across profiles.\n\n### PowerShell\n\n> # All users on the host: find newest Chrome History DBs across profiles\n> Get-ChildItem \"C:\\Users\\*\\AppData\\Local\\Google\\Chrome\\User Data\\*\\History\" -File -ErrorAction SilentlyContinue |\n>   Sort-Object LastWriteTime -Descending |\n>   Select-Object -First 12 FullName, LastWriteTime, Length\n\n> # Single target user: fastest if you already know the user context\n> Get-ChildItem \"C:\\Users\\JaneDoe\\AppData\\Local\\Google\\Chrome\\User Data\\*\\History\" -File -ErrorAction SilentlyContinue |\n>   Sort-Object LastWriteTime -Descending |\n>   Select-Object -First 8 FullName, LastWriteTime, Length\n\n### JaneDoe quick explanations\n\n- Find latest History files\n- Confirm active Chrome profile\n- Prioritize latest investigation window\n\n### Copy the chosen History file for analysis\n\nCopying the `History` DB to a working path reduces lock issues and preserves original evidence paths for reporting. Ideally, this is done with response tools to remotely extract the file.\n\n## 2) Anchor the timeline on the suspected download\n\nThe next goal is to locate the download record for `SuspiciousPDFConverter.exe` so we can pivot from a **download timestamp** into the last ~15–20 navigations that likely led to it.\n\n### Example “defanged” target you’re hunting\n\n- Filename on disk: `SuspiciousPDFConverter.exe`\n- Example download URL (fake/defanged): `hxxps://cdn[.]pdf-suspicious-tools[.]example/download/SuspiciousPDFConverter.exe`\n- Example referrer (fake/defanged): `hxxps://viewer[.]docs-preview[.]example/redirect?id=123`\n\n## 3) Chrome History SQLite: table nuances\n\nChrome’s `History` file is SQLite, and your interpretation depends on which tables are present in your Chrome version and enterprise policy set.\n\n**Notes:** Chrome schema can shift between versions, so confirm table/column existence before assuming field names or meanings.\n\n### Tables you’ll commonly use in this workflow\n\n- `downloads` — What was downloaded and when (fields vary by version)\n- `downloads_url_chains` — Redirect chain for a download (when present)\n- `visits` — Individual navigation events with timestamps and transition types\n- `urls` — URL strings, titles, visit counters, last_visit_time\n- `visit_source` — May hint whether a visit was local vs synced (when present)\n\n## 4) SQL: find the download record (then pivot to “what happened before it”)\n\nYour first query anchors on the suspected executable name so you can capture the download ID and its timestamp fields for timeline pivots.\n\n> -- Find the most recent download matching the filename (columns may differ by Chrome version).\n> -- Notes: confirm whether your schema uses current_path, target_path, tab_url, referrer, etc.\n> SELECT\n>   id,\n>   current_path,\n>   target_path,\n>   tab_url,\n>   referrer,\n>   mime_type,\n>   received_bytes,\n>   total_bytes,\n>   danger_type,\n>   state,\n>   datetime((start_time/1000000)-11644473600,'unixepoch') AS start_utc,\n>   datetime((end_time/1000000)-11644473600,'unixepoch')   AS end_utc\n> FROM downloads\n> WHERE (current_path LIKE '%SuspiciousPDFConverter.exe%'\n>        OR target_path LIKE '%SuspiciousPDFConverter.exe%')\n> ORDER BY start_time DESC\n> LIMIT 5;\n\n### Follow-up: pull the redirect chain for that download (if available)\n\nThis query shows the chain of URLs Chrome recorded for the download (often the cleanest way to show redirect-to-download behavior).\n\n> -- Replace :download_id with the downloads.id you identified above.\n> SELECT\n>   chain_index,\n>   url\n> FROM downloads_url_chains\n> WHERE id = :download_id\n> ORDER BY chain_index ASC;\n\n**Notes:** If `downloads_url_chains` is missing or empty, you’ll rely more heavily on `visits` + `urls` around the download time and any referrer/tab_url fields in `downloads`.\n\n## 5) SQL: last 15–20 URL visits leading up to the download\n\nOnce you have a download start timestamp, you can pull the last 15–20 visits at or before that moment to reconstruct the likely navigation chain.\n\n> -- Pivot: last 20 visits at/before the most recent matching download start_time.\n> -- Notes: validate whether start_time is present and in WebKit microseconds.\n> WITH d AS (\n>   SELECT start_time AS dl_time\n>   FROM downloads\n>   WHERE (current_path LIKE '%SuspiciousPDFConverter.exe%'\n>          OR target_path LIKE '%SuspiciousPDFConverter.exe%')\n>   ORDER BY start_time DESC\n>   LIMIT 1\n> )\n> SELECT\n>   datetime((v.visit_time/1000000)-11644473600,'unixepoch') AS visit_utc,\n>   u.url,\n>   u.title,\n>   v.transition,\n>   v.from_visit\n> FROM visits v\n> JOIN urls u ON v.url = u.id\n> JOIN d ON 1=1\n> WHERE v.visit_time <= d.dl_time\n> ORDER BY v.visit_time DESC\n> LIMIT 20;\n\n**Notes:** `transition` is a bitmask that can indicate typed, link, redirect, auto-subframe, etc., and decoding it can help you argue whether the chain looks user-driven or script-driven.\n\n### Show the first visit after the download started (sanity check)\n\nThis helps confirm whether the user continued browsing into additional lure pages immediately after initiating the download.\n\n> WITH d AS (\n>   SELECT start_time AS dl_time\n>   FROM downloads\n>   WHERE (current_path LIKE '%SuspiciousPDFConverter.exe%'\n>          OR target_path LIKE '%SuspiciousPDFConverter.exe%')\n>   ORDER BY start_time DESC\n>   LIMIT 1\n> )\n> SELECT\n>   datetime((v.visit_time/1000000)-11644473600,'unixepoch') AS visit_utc,\n>   u.url,\n>   u.title\n> FROM visits v\n> JOIN urls u ON v.url = u.id\n> JOIN d ON 1=1\n> WHERE v.visit_time > d.dl_time\n> ORDER BY v.visit_time ASC\n> LIMIT 10;\n\n## 6) How to turn these artifacts into a defensible conclusion\n\nYour conclusion should tie together (1) the download record, (2) the redirect chain (if available), and (3) the surrounding visit timeline to show how the user arrived at the executable.\n\n**Notes:** Add screenshots of the query output and highlight the pivot points (download start time, referrer/tab_url, chain_index ordering, and the last 15–20 visits).\n\n### Example narrative scaffold:\n\n- The host generated a detection for `SuspiciousPDFConverter.exe`, prompting a browser-artifact review to determine acquisition path.\n- The most recently written Chrome `History` database identified the active profile during the suspected time window.\n- A matching record in the `downloads` table provided an anchor timestamp and contextual fields (e.g., `tab_url`, `referrer`) for pivots.\n- The `downloads_url_chains` table (when present) revealed a stepwise redirect chain from lure infrastructure to the final CDN-hosted payload.\n- The `visits` + `urls` pivot showed the final 15–20 navigations preceding the download, supporting a drive-by/redirect delivery hypothesis.\n\n\n## Closing thoughts\n\nThe goal of browser history forensics is not to “prove intent,” but to produce a clear, evidence-backed chain of events that explains how a suspicious payload was retrieved when traditional telemetry is incomplete.",
    "tags": [
      "DFIR",
      "Browser Artifacts",
      "Chrome",
      "MITRE ATT&CK: Initial Access",
      "T1189 Drive-by Compromise"
    ],
    "readMinutes": 6,
    "wordCount": 1380
  },
  {
    "title": "Public and Untrusted WiFi Networks",
    "date": "2025-04-08",
    "excerpt": "A practical breakdown of why public WiFi still carries risk even with HTTPS, and how to reduce exposure.",
    "url": "/blogs/post.html?post=public_wifi",
    "slug": "public_wifi",
    "source": "/blogs/public_wifi.md",
    "markdown": "## Public and Untrusted WiFi Networks\n\nPublic WiFi is convenient, but convenience often means reduced trust. Even with HTTPS everywhere, there are still privacy, interception, and misconfiguration risks that can expose users and organizations.\n\n![Public WiFi warning visual](/images/disclaimer.png)\n\n### Common risks on untrusted networks\n\n- **Evil twin access points:** attacker-controlled hotspots that mimic legitimate SSIDs.\n- **Traffic interception attempts:** DNS manipulation, captive portal abuse, and downgrade attempts.\n- **Device exposure:** accidental sharing services and stale local trust settings.\n- **Session hijacking opportunities:** especially with weakly protected web sessions.\n\n### Practical hardening steps (iOS and Android)\n\n1. **Prefer cellular data** for sensitive sessions.\n2. **Use a trusted VPN** when WiFi is unavoidable.\n3. **Disable auto-join** for unknown or open networks.\n4. **Use randomized/private MAC addresses** on every network.\n5. **Enable private DNS / encrypted DNS** where possible.\n6. **Keep OS and apps updated** to reduce exploitability.\n7. **Restrict app permissions** to minimum required access.\n8. **Avoid high-risk actions** (banking, corporate admin portals) on public WiFi.\n9. **Use MFA** for all critical accounts.\n10. **Turn off nearby sharing services** when not needed.\n\n### Defensive operating habits\n\n- Verify the hotspot name with staff before connecting.\n- Treat captive portals as untrusted input.\n- Log out after completing sessions.\n- Restart your device after disconnecting from risky networks.\n\n### Disclaimer\n\nThis material is educational and informational only. It is not legal advice and does not guarantee security outcomes. Always align controls with your organization’s policies and legal obligations.\n\n### References\n\n- https://www.fox5vegas.com/2024/08/08/las-vegas-police-issues-cyber-advisory-with-cybersecurity-hacker-conventions-town/\n- https://en.wikipedia.org/wiki/Kazakhstan_man-in-the-middle_attack",
    "tags": [
      "Network Security",
      "Risk Management",
      "Privacy"
    ],
    "readMinutes": 1,
    "wordCount": 249
  },
  {
    "title": "iPod Classic Flash Mod Rebuild",
    "date": "2025-01-15",
    "excerpt": "A professional-ish walkthrough of how I rebuilt an iPod Classic with flash storage and a higher-capacity battery using parts from Elite Obsolete.",
    "url": "/blogs/post.html?post=ipod_classic_flash_mod_rebuild",
    "slug": "ipod_classic_flash_mod_rebuild",
    "source": "/blogs/ipod_classic_flash_mod_rebuild.md",
    "markdown": "## Intro\n\nIn January 2025, I rebuilt a 5th-gen iPod Classic as a small “reliability upgrade” project for the battery and the storage. \n\n![Parts laid out before reassembly](/images/ipod-flash-mod-01-parts-laid-out.jpg)\n\nWith many services moving to a subscription model accessible via the cloud and an internet connection, it's difficult to maintain a library of music that is available whenever and wherever you wish. \n\nAdditionally, for those that wish to establish a reduction in their internet-connected/wireless footprint, you'll be hard pressed to find a reliable, internet(less) device with plenty of storage capacity that has a long enough battery charge to last through weekend trips. \n\nI say why reinvent the wheel. The iPod Classic was a revolution in its time, and with the right parts, you can supercharge certain aspects of iPod Classic. With a conversion board that takes a micro SD card, and a 3000 mAh battery, you can extend the life of this legacy technology. \n\nThe original battery hovers around 850 mAh, and the hard disk ranged from ~30 GB - ~80 GB. With a 128 GB micro SD card and the vast battery capacity increase, the improvement is rather insane.\n\n\"Done\" for me is ending up with a device that I can use for many days without charging and without running out of storage, and these upgrades fit the bill for me. \n\n## What I started with\n\nThe baseline was a black iPod Classic (5th gen) that still had the original hard drive.\n\n![Original hard drive (before removal)](/images/ipod-flash-mod-02-original-hard-drive.jpg)\n\nThe drive clicked, crashed, and wouldn't flash anyways. The upgrade was very necessary. Additionally, the original battery did not hold a charge. \n\nThe drive also was not snappy or fast, which shouldn't be surprising. It was worth my time diagnosing these issues, since they could've been used in other projects.\n\n## Parts I used\n\nThese were the parts that made the rebuild possible.\n\n- **Tarkan iFlash Solo (SD / microSD ZIF adapter)** — replaces the HDD with flash storage.\n- **Tarkan iFlash 40-pin ZIF HDD flex cable** — avoids fighting an old/brittle ribbon.\n- **3000mAh “thick” extended battery** — improves runtime and offsets flash mod “why not” energy.\n- **Kapton tape (ESD/heat resistant)** — insulation + strain relief where you *really* don’t want shorts.\n- **Red double-sided adhesive tape** — mounting the battery cleanly without rattles.\n\nIn order to fit the 3000 mAh battery within the new case, a foam block holding up the headphone assembly needed to be removed. The 3000 mAh was the approximate correct height (just as large as the foam block was tall), so this was not an issue. The double-sided tape held the battery firmly in place. Kapton ESD tape was used to cover the back and front of the iFlash Solo to prevent electrical shorts, which is possible, given the conductivity of the case and other components. \n\n## The build workflow\n\nThis is the high-level process I followed to keep it clean and repeatable.\n\n1. Open the clamshell with a knife blade and the separator.\n2. Disconnect the battery early so nothing is “live” while moving ribbons and boards around.\n3. Remove the original hard drive and set it aside.\n4. Install the iFlash Solo + replacement ZIF cable and confirm the connector is fully seated and aligned.\n5. Insulate and secure the adapter/cable path with Kapton so it can’t rub or pinch when closed.\n6. Install and mount the new battery using adhesive so it won’t shift inside the enclosure.\n7. Do a dry-fit close (no force) to confirm nothing is bulging or being crushed.\n8. Restore the firmware (reformat) and verify stable boot + sync before calling it done.\n\n![Plugging in the iFlash Solo adapter](/images/ipod-flash-mod-03-plugging-in-iflash-solo.jpg)\n\nConnecting the iFlash Solo with the ZIF cable is exceedinly difficult, given that the cable is held with pressure from the connector. It is important to verify that while connecting the ZIF cable, you make positive connections to the connectors, which isn't an exact \"the sky is blue\" feeling. \n\nIt is a subjective feeling that is only verified with intuition, as each connector and each iPod feels different, according to what I've read online from others' experiences. I can only make an educated guess as to why this is; whether or not the drive has been previously replaced before, and creates \"wear\", or otherwise. \n\n## Things that mattered more than I expected\n\nThese are the “small details” that keep the mod from turning into a troubleshooting session.\n\n- ZIF connector alignment is everything (crooked seating can look “connected” but fail later).\n- Cable routing matters because the iPod case will happily pinch anything in its way.\n- Insulation is not optional when you’ve got tight tolerances and exposed pads.\n- Battery thickness needs to match the backplate (thin vs thick) or closure becomes a problem.\n- Testing before final close saves the most time (boot, hold switch, clickwheel, audio, sync).\n\n## Result\n\nThe finished device boots cleanly and feels like a modernized version of the original, while maintaining the classic look.\n\n![iPod reassembled and powered on](/images/ipod-flash-mod-04-finished-powered-on.jpg)\n\nI noticed that my iPod lasts days instead of hours, has great sound quality for my requirements, and has plenty of storage.",
    "tags": [
      "Hardware",
      "DIY",
      "Repair",
      "iPod",
      "Homelab"
    ],
    "readMinutes": 4,
    "wordCount": 826
  },
  {
    "title": "Obsidian Threat Heat Map",
    "date": "2024-12-09",
    "excerpt": "Using an Obsidian workflow to visualize incident relationships and identify recurring threat patterns.",
    "url": "/blogs/post.html?post=obsidian_threat_heat_map",
    "slug": "obsidian_threat_heat_map",
    "source": "/blogs/obsidian_threat_heat_map.md",
    "markdown": "## Obsidian Threat Heat Map\n\nHaving a repeatable way to track incidents is critical if you want to derive trends, improve triage, and predict risk over time. This workflow repurposes Obsidian graph features as a lightweight threat relationship map.\n\n> **No real incident data is used in this example.**\n> All data is fake and intentionally defanged.\n\n![A beautiful heatmap in Obsidian](/images/obsidian-heatmap.png)\n\n### 1) Defang your IOCs before anything else\n\nUse CyberChef (or equivalent) to neutralize indicators such as IPs, domains, URLs, and email addresses before storing or sharing.\n\n![Defanging fake IOCs](/images/cyberchef.png)\n\n### 2) Bulk-tag indicators to speed up linking\n\nAfter you prepare a list of IOCs in a text editor, wrap each IOC in Obsidian wiki-link syntax (`[[...]]`). This causes each IOC to become a linked object in the graph.\n\n![Performing mass text manipulation](/images/textmanipulation.png)\n\n### 3) Use a consistent incident template\n\nA consistent template prevents missing fields and keeps your graph meaningful as your data set grows.\n\n![Template incident report](/images/obsidiantemplate.png)\n\n### 4) Build relationships across incidents\n\nLoad your tagged IOCs into multiple incidents. Shared artifacts automatically create graph relationships.\n\n![Tagged and defanged IOCs loaded](/images/taggediocs.png)\n\nAs your case volume grows, linked artifacts make it easier to identify recurring campaigns, repeated targets, and hotspot clusters.\n\n![Observing links in graph view](/images/furtherlinks.png)\n\n### Why this helps\n\n- Visualizes incident overlap over time.\n- Highlights repeated attacker infrastructure.\n- Surfaces frequent target groups/departments.\n- Makes trend communication easier for leadership.\n\n### Closing thoughts\n\nThis is not a replacement for full-scale threat intelligence platforms. It is a practical and low-friction workflow for teams already using Obsidian that want better visibility with minimal overhead.",
    "tags": [
      "Threat Modeling",
      "Obsidian",
      "SOC Workflow"
    ],
    "readMinutes": 1,
    "wordCount": 234
  }
]
